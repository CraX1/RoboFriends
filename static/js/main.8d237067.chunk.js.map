{"version":3,"sources":["reportWebVitals.js","Components/Card.js","Components/Cardlist.js","Components/Searchbox.js","Components/Scroll.js","ErrorBoundary.js","Containers/App.js","index.js"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","Card","name","email","id","className","src","width","height","alt","cardList","props","robo","map","user","i","search","searchChange","type","placeholder","onChange","Scroll","style","overflow","border","children","ErrorBoundary","state","hasError","error","info","this","setState","Component","App","onSearchChange","event","Search","target","value","fetch","response","json","users","filterSearch","filter","robot","toLowerCase","includes","console","log","Searchbox","Cardlist","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"0MAYeA,G,MAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,Q,2CCWCQ,EAhBF,SAAC,GAAmB,IAAlBC,EAAiB,EAAjBA,KAAKC,EAAY,EAAZA,MAAMC,EAAM,EAANA,GAEtB,OACI,sBAAKC,UAAU,sDAAf,UACI,qBAAKC,IAAG,+BAA0BF,GAAMG,MAAM,MAAMC,OAAQ,MAAMC,IAAI,SACtE,gCAII,6BAAKP,IAJT,IAKI,4BAAIC,WCYLO,EApBC,SAACC,GAEb,OACI,8BAGQA,EAAMC,KAAKC,KAAI,SAACC,EAAKC,GACjB,OACA,cAAC,EAAD,CAEAX,GAAIO,EAAMC,KAAKG,GAAGX,GAClBF,KAAMS,EAAMC,KAAKG,GAAGb,KACpBC,MAAOQ,EAAMC,KAAKG,GAAGZ,OAHhBQ,EAAMC,KAAKG,GAAGX,UCHxBY,EARF,SAAC,GAAkB,IAAjBC,EAAgB,EAAhBA,aACX,OACI,qBAAKZ,UAAU,MAAf,SACI,uBAAOA,UAAU,mCAAmCa,KAAK,SAASC,YAAY,OAAOC,SAAUH,OCI5FI,G,MAPA,SAACV,GACZ,OACI,sBAAKW,MAAO,CAACC,SAAW,SAASC,OAAO,kBAAmBhB,OAAO,SAAlE,cACKG,EAAMc,cCHEC,E,kDACjB,WAAYf,GAAO,IAAD,8BACd,cAAMA,IACDgB,MAAM,CACPC,UAAS,GAHC,E,qDAOlB,SAAkBC,EAAOC,GACrBC,KAAKC,SAAS,CAACJ,UAAS,M,oBAG5B,WACI,OAAGG,KAAKJ,MAAMC,SACH,8DAEJG,KAAKpB,MAAMc,a,GAhBiBQ,aCqE5BC,E,kDAzDX,aAAc,IAAD,8BACT,gBAsBJC,eAAe,SAACC,GAEZ,EAAKJ,SAAS,CAACK,OAAOD,EAAME,OAAOC,SAvBnC,EAAKZ,MAAM,CACPf,KAAK,GACLyB,OAAO,IAJF,E,qDAOb,WAAoB,IAAD,OACfG,MAAM,8CACL7C,MAAK,SAAA8C,GACF,OAAOA,EAASC,UAEnB/C,MAAK,SAAAgD,GACF,EAAKX,SAAS,CAACpB,KAAK+B,S,oBAmB5B,WAMI,MAAuBZ,KAAKJ,MAApBf,EAAR,EAAQA,KAAMyB,EAAd,EAAcA,OACRO,EAAchC,EAAKiC,QAAO,SAACC,GAC7B,OAAOA,EAAM5C,KAAK6C,cAAcC,SAASX,EAAOU,kBAGpD,OADAE,QAAQC,IAAI,UAER,sBAAK7C,UAAW,KAAhB,UACI,6CACA,cAAC8C,EAAD,CAAWlC,aAAcc,KAAKI,iBAE9B,eAAC,EAAD,eACG,cAAC,EAAD,UACC,cAACiB,EAAD,CAAUxC,KAAMgC,gB,GAnDlBX,aCLlBoB,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BjE,M","file":"static/js/main.8d237067.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\n\r\nconst Card = ({name,email,id})=>{\r\n    // const {name,email,id}=props; or just do this destructuring inside the parameter\r\n    return(\r\n        <div className='tc bg-light-green dib br3 ma3 pa2 grow bw2 shadow-2'>\r\n            <img src={`https://robohash.org/${id}`} width='200' height= '200' alt='ROBO' />\r\n            <div>\r\n                {/* <h1>{props.name}</h1>\r\n                <p>{props.email}</p> not a cleaner way */}\r\n\r\n                <h1>{name}</h1> {/* much cleaner */}\r\n                <p>{email}</p>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Card;","import React from 'react';\r\nimport Card from './Card'\r\n//we used {robo} beacause robo has multiple data and its not using default export\r\n\r\nconst cardList= (props)=>{\r\n  \r\n    return(\r\n        <div>\r\n            \r\n            {\r\n                props.robo.map((user,i)=>{\r\n                    return (\r\n                    <Card \r\n                    key={props.robo[i].id} \r\n                    id={props.robo[i].id} \r\n                    name={props.robo[i].name} \r\n                    email={props.robo[i].email}\r\n                    \r\n                    />)\r\n                })\r\n            }\r\n        </div>\r\n    );\r\n}\r\nexport default cardList;","import React from 'react';\r\n\r\nconst search=({searchChange})=>{ //here we are passing seachchange as a destructor\r\n    return(\r\n        <div className='pa2'>\r\n            <input className='pa3 ba b--green bg-lightest-blue' type='search' placeholder='who?' onChange={searchChange} />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default search;","import React from 'react'\r\n// now you can use 'children' like there was 'state' to render the childrn of scroll\r\nconst Scroll = (props) => {\r\n    return (\r\n        <div style={{overflow : 'scroll',border:'1px solid black', height:'380px'}}> {/*in jsx to use style use double curly braces  */}\r\n            {props.children}\r\n        </div>\r\n    )\r\n}\r\nexport default Scroll","import React, { Component } from 'react'\r\n\r\nexport default class ErrorBoundary extends Component {\r\n    constructor(props){\r\n        super(props)\r\n        this.state={\r\n            hasError:false\r\n        }\r\n    }\r\n\r\n    componentDidCatch(error, info){   //if theres any error this lifecycle hook will run just like catch and throw in js\r\n        this.setState({hasError:true})  //means if the component has error this method will return haserror to true which will then run in the if statement\r\n    }\r\n\r\n    render() {\r\n        if(this.state.hasError){\r\n            return <h1>there is some error.Wait...!</h1>\r\n        }\r\n        return this.props.children\r\n    }\r\n}\r\n","import React from 'react';\r\nimport Cardlist from '../Components/Cardlist';\r\nimport Searchbox from '../Components/Searchbox.js'\r\n// import {robo} from './robo'\r\nimport { Component } from 'react';\r\nimport './App.css'\r\nimport Scroll from '../Components/Scroll'\r\nimport ErrorBoundary from '../ErrorBoundary'\r\n// const state={  to use state you need to create a constructor and specify this.state\r\n//     robo: robo,\r\n//     Searchbox:''\r\n// }\r\n\r\nclass App extends Component{\r\n    constructor(){\r\n        super() // to use'this' you have to use super() which calls the constructor of the parent class which is component here\r\n        this.state={\r\n            robo:[],\r\n            Search:''\r\n        }\r\n    }\r\n    componentDidMount(){ //gets called after render  This says that yes, the app component is mounted on the web page, and it is rendered, that is it's displaying something.\r\n        fetch('https://jsonplaceholder.typicode.com/users')\r\n        .then(response=>{\r\n            return response.json();\r\n        })\r\n        .then(users=>{\r\n            this.setState({robo:users})\r\n        })\r\n    }   \r\n\r\n    // we passed down \"onSearchChange\" to the \"SearchBox\", \r\n    // and in the \"SearchBox\", every time there's an \"onChange\" on the input,\r\n    // it lets the app know \"Hey, there was a change\"\r\n    // \"Run this function\"\r\n    // It runs the function with the event and updates the state of the \"searchBox\" to whatever we type\r\n        //remember with an event there is always event.target.value\r\n    onSearchChange=(event)=>{ \r\n        //also in react whenevr you want to change state use this.setState\r\n        this.setState({Search:event.target.value})\r\n        //we cant access filterSearch in seachbox from here so insteead we use it inside render\r\n        // const filterSearch= this.state.robo.filter((robot)=>{ //here the value of'this is not refering to the App class as the event happend in the input of Searchbox component and input doesnt have state.robot so we instead use arrow function and it will work fine and always use arrow function only while creating a method\r\n        //     return robot.name.toLowerCase().includes(this.state.Searchbox.toLowerCase())\r\n        // })\r\n    }\r\n\r\n    render() {\r\n        //now we can pass filetrSearch as property instead of passing this.state.robot\r\n        // Now with the information that we have from the search box we can now communicate to the card list and\r\n        // tell it \"Hey, I want to filter the \"robots\" state to now have only what includes in the \"searchBox\"\r\n       \r\n       //instead of using this.state again and again\r\n        const { robo, Search }=this.state;       \r\n        const filterSearch= robo.filter((robot)=>{ //here the value of'this is not refering to the App class as the event happend in the input of Searchbox component and input doesnt have state.robot so we instead use arrow function and it will work fine and always use arrow function only while creating a method\r\n            return robot.name.toLowerCase().includes(Search.toLowerCase())\r\n        })\r\n        console.log('render')\r\n        return (\r\n            <div className= 'tc'>\r\n                <h1>ROBOfRIENDS</h1>\r\n                <Searchbox searchChange={this.onSearchChange}/>\r\n                {/* <Cardlist robo={robo}/> So now we can acces robo simply with the help of this.state */}\r\n                <Scroll> {/* by wrapping cardlist inside scroll you can create a scroll comp which helps ypir card to be scrolable */}\r\n                   <ErrorBoundary>\r\n                    <Cardlist robo={filterSearch}/>{/*now robo is passed down as props with the help of state */}\r\n                   </ErrorBoundary> \r\n                </Scroll>\r\n            </div>\r\n        );\r\n};\r\n}\r\nexport default App;\r\n\r\n\r\n\r\n// We have our \"App\" component that has two states - \"robots\" and \"searchfield\"\r\n// And because \"App\" owns the state, any component that has \"state\" uses the \"class\" syntax so they can use the\r\n// \"constructor\" function to create \"this.state\", and this \"state\" is what changes in an app\r\n// It's what describes the app\r\n// We manage this state in here, the app is the only thing that can change this state\r\n// But it can pass down things such as props, so we passed down \"onSearchChange\" to the \"SearchBox\", \r\n// and in the \"SearchBox\", every time there's an \"onChange\" on the input,\r\n// it lets the app know \"Hey, there was a change\"\r\n// \"Run this function\"\r\n// It runs the function with the event and updates the state of the \"searchfield\" to whatever we type\r\n// Now with the information that we have from the search box we can now communicate to the card list and\r\n// tell it \"Hey, I want to filter the \"robots\" state to now have only what includes in the \"searchfield\"\r\n// and instead of passing that \"this.state\" to our \"robots\" we just passed the \"filteredRobots\"\r\n\r\n\r\n\r\n// MOUNTING =basically measn replacing the root in div with the app when you refresh the page\r\n// These methods are called in the following order when an instance of a component is being created and inserted into the DOM:\r\n\r\n// constructor()\r\n// static getDerivedStateFromProps()\r\n// render()\r\n// componentDidMount()\r\n\r\n\r\n// Updating\r\n// An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered(when we change thhe search content)\r\n\r\n// static getDerivedStateFromProps()\r\n// shouldComponentUpdate()\r\n// render()\r\n// getSnapshotBeforeUpdate()\r\n// componentDidUpdate()\r\n\r\n\r\n// Unmounting\r\n// This method is called when a component is being removed from the DOM:\r\n\r\n// componentWillUnmount()\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport 'tachyons';\nimport App from './Containers/App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}